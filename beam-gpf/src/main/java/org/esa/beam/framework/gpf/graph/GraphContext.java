package org.esa.beam.framework.gpf.graph;

import org.esa.beam.framework.datamodel.Product;
import org.esa.beam.framework.gpf.Tile;

import java.awt.Dimension;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

/**
 * The <code>GraphProcessor</code> is responsible for executing processing
 * graphs.
 *
 * @author Norman Fomferra
 * @author Marco Peters
 * @since 4.1
 */
public class GraphContext {

    private Graph graph;
    private Logger logger;
    private Dimension preferredTileSize;
    private Map<Node, NodeContext> nodeContextMap;
    private List<NodeContext> outputNodeContextList;
    private ArrayDeque<NodeContext> initNodeContextDeque;


    /**
     * Creates a GraphProcessor.
     */
    public GraphContext(Graph graph, Logger logger) {
        this.graph = graph;
        this.logger = logger;

        preferredTileSize = new Dimension(Tile.DEFAULT_TILE_SIZE, Tile.DEFAULT_TILE_SIZE);

        outputNodeContextList = new ArrayList<NodeContext>(graph.getNodeCount() / 2);

        nodeContextMap = new HashMap<Node, NodeContext>(graph.getNodeCount() * 2);
        for (Node node : graph.getNodes()) {
            nodeContextMap.put(node, new NodeContext(this, node));
        }

        initNodeContextDeque = new ArrayDeque<NodeContext>(graph.getNodeCount());
    }

    public Graph getGraph() {
        return graph;
    }

    public Logger getLogger() {
        return logger;
    }

    /**
     * Gets the preferred tile size.
     *
     * @return the preferred tile size
     */
    public Dimension getPreferredTileSize() {
        return preferredTileSize;
    }

    /**
     * Sets the preferred tile size.
     */
    public void setPreferredTileSize(Dimension preferredTileSize) {
        this.preferredTileSize = preferredTileSize;
    }

    /**
     * Returns an array containing the output products generated by this graph's output
     * nodes, i.e. nodes that are not input to other nodes.
     *
     * @return an array containing the output products of this graph.
     */
    public Product[] getOutputProducts() {
        Product[] products = new Product[outputNodeContextList.size()];
        for (int i = 0; i < products.length; i++) {
            products[i] = outputNodeContextList.get(i).getTargetProduct();
        }
        return products;
    }

    NodeContext getNodeContext(Node node) {
        return nodeContextMap.get(node);
    }

    NodeContext getOutputNodeContext(int i) {
        return outputNodeContextList.get(i);
    }

    NodeContext[] getOutputNodeContexts() {
        return outputNodeContextList.toArray(new NodeContext[outputNodeContextList.size()]);
    }

    int getTotalOutputBandCount() {
        int bandCount = 0;
        for (NodeContext nodeContext : outputNodeContextList) {
            bandCount += nodeContext.getTargetProduct().getNumBands();
        }
        return bandCount;
    }

    void addOutputNodeContext(NodeContext nodeContext) {
        outputNodeContextList.add(nodeContext);
    }

    public int getOutputCount() {
        int outputCount = 0;
        for (Node node : graph.getNodes()) {
            NodeContext nodeContext = getNodeContext(node);
            if (nodeContext.isOutput()) {
                outputCount++;
            }
        }
        return outputCount;
    }

    public Deque<NodeContext> getInitNodeContextDeque() {
        return initNodeContextDeque;
    }
}
